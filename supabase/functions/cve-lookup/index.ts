import { serve } from "https://deno.land/std@0.168.0/http/server.ts";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type, x-supabase-client-platform, x-supabase-client-platform-version, x-supabase-client-runtime, x-supabase-client-runtime-version',
};

// CPE vendor mapping for common technologies
const TECH_CPE_MAP: Record<string, { vendor: string; product: string }> = {
  'jQuery': { vendor: 'jquery', product: 'jquery' },
  'WordPress': { vendor: 'wordpress', product: 'wordpress' },
  'React': { vendor: 'facebook', product: 'react' },
  'Angular': { vendor: 'google', product: 'angular' },
  'Vue.js': { vendor: 'vuejs', product: 'vue' },
  'Next.js': { vendor: 'vercel', product: 'next.js' },
  'Bootstrap': { vendor: 'getbootstrap', product: 'bootstrap' },
  'Drupal': { vendor: 'drupal', product: 'drupal' },
  'PHP': { vendor: 'php', product: 'php' },
  'Nginx': { vendor: 'f5', product: 'nginx' },
  'ASP.NET': { vendor: 'microsoft', product: 'asp.net' },
  'Shopify': { vendor: 'shopify', product: 'shopify' },
  'HubSpot': { vendor: 'hubspot', product: 'hubspot' },
  'Stripe': { vendor: 'stripe', product: 'stripe' },
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { technologies } = await req.json();
    if (!technologies || !Array.isArray(technologies) || technologies.length === 0) {
      return new Response(JSON.stringify({ error: 'technologies array is required', cves: [] }), {
        status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    console.log('Looking up CVEs for technologies:', technologies);

    const allCves: Array<{
      technology: string;
      cveId: string;
      description: string;
      severity: string;
      cvssScore: number | null;
      publishedDate: string;
      references: string[];
    }> = [];

    // Look up CVEs for each technology using NVD API
    for (const tech of technologies) {
      const cpeInfo = TECH_CPE_MAP[tech];
      if (!cpeInfo) continue;

      try {
        const cves = await fetchNvdCves(cpeInfo.vendor, cpeInfo.product);
        for (const cve of cves) {
          allCves.push({
            technology: tech,
            ...cve,
          });
        }
      } catch (e) {
        console.warn(`CVE lookup failed for ${tech}:`, e);
      }

      // NVD rate limit: max 5 requests per 30 seconds without API key
      await new Promise(r => setTimeout(r, 6500));
    }

    // Sort by CVSS score descending, then by date
    allCves.sort((a, b) => (b.cvssScore || 0) - (a.cvssScore || 0));

    return new Response(JSON.stringify({
      success: true,
      totalCves: allCves.length,
      technologiesChecked: technologies.filter(t => TECH_CPE_MAP[t]),
      technologiesSkipped: technologies.filter(t => !TECH_CPE_MAP[t]),
      cves: allCves.slice(0, 50), // Cap at 50 most severe
    }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });

  } catch (error) {
    console.error('CVE lookup error:', error);
    return new Response(JSON.stringify({
      error: error instanceof Error ? error.message : 'CVE lookup failed',
      cves: [],
    }), {
      status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  }
});

async function fetchNvdCves(vendor: string, product: string): Promise<Array<{
  cveId: string;
  description: string;
  severity: string;
  cvssScore: number | null;
  publishedDate: string;
  references: string[];
}>> {
  // Use NVD 2.0 API â€” keyword search (free, no API key required, 5 req/30s)
  const keyword = `${vendor} ${product}`;
  const url = `https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch=${encodeURIComponent(keyword)}&resultsPerPage=10`;

  const resp = await fetch(url, {
    headers: { 'User-Agent': 'ThreatLens/1.0' },
  });

  if (!resp.ok) {
    console.warn(`NVD API error for ${keyword}:`, resp.status);
    return [];
  }

  const data = await resp.json();
  const vulnerabilities = data.vulnerabilities || [];

  return vulnerabilities.map((v: any) => {
    const cve = v.cve;
    const cveId = cve.id;
    const description = cve.descriptions?.find((d: any) => d.lang === 'en')?.value || 'No description available';

    // Extract CVSS v3.1 or v3.0 score
    const cvssV31 = cve.metrics?.cvssMetricV31?.[0]?.cvssData;
    const cvssV30 = cve.metrics?.cvssMetricV30?.[0]?.cvssData;
    const cvss = cvssV31 || cvssV30;

    const cvssScore = cvss?.baseScore || null;
    const severity = cvss?.baseSeverity?.toLowerCase() || 
      (cvssScore ? (cvssScore >= 9 ? 'critical' : cvssScore >= 7 ? 'high' : cvssScore >= 4 ? 'medium' : 'low') : 'unknown');

    const publishedDate = cve.published || '';
    const references = (cve.references || []).map((r: any) => r.url).slice(0, 3);

    return { cveId, description, severity, cvssScore, publishedDate, references };
  });
}